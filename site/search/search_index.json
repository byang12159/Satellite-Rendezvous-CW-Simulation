{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"calc/","text":"Mechanics of Calculations Variables \\(r\\) = radius of target spacecraft's circular orbit \\(\\mu\\) = standard gravitational parameter \\(n\\) = mean motion of the target spacecraft (1) $$ n = \\sqrt{\\frac{ {\\mu} }{r^3}} $$ Clohesy Whiltshire Equation \\[ \\ddot x - 2n\\dot y - 3n^2x = a_{x} \\] \\[ \\ddot y + 2n\\dot x = a_{y} \\] \\[ \\ddot z + n^2 z = a_{z} \\] \\[ Thrust F_{x} = m_{Satellite}/ a_{x} \\] \\[ Thrust_{y} = F_{y}/m_{Satellite} \\] \\[ Thrust_{x} = F_{z}/m_{Satellite} \\] The Clohessy Whiltshire update is rewritten in matrix format as: \\(\\left[\\begin{array}{cc} \\dot x \\\\ \\dot y \\\\ \\dot z \\\\ \\dot v_{x} \\\\ \\dot v_{y} \\\\ \\dot v_{z} \\end{array}\\right] =\\) \\(\\left[\\begin{array}{cc} 0 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 3n^2 & 0 & 0 & 2n & 0 & 0 \\\\ 0 & -2n & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -n^2 & 0 \\end{array}\\right] *\\) \\(\\left[\\begin{array}{cc} x \\\\ y \\\\ z \\\\ v_{x} \\\\ v_{y} \\\\ v_{z} \\end{array}\\right] +\\) \\(\\left[\\begin{array}{cc} 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{array}\\right] *\\) \\(\\left[\\begin{array}{cc} F_{x} \\\\ F_{y} \\\\ F_{z} \\end{array}\\right]\\) This is mapped out in the Relative Trajectory function: def reltrajectorygenerate(self,U,x): accel = self.controller() return [U[3], U[4], U[5], 3*(self.n**2)*U[0]+2*self.n*U[4] + accel[0], -2*self.n*U[3] + accel[1], -(self.n**2)*U[2] + accel[2]]","title":"Mechanics"},{"location":"calc/#mechanics-of-calculations","text":"","title":"Mechanics of Calculations"},{"location":"calc/#variables","text":"\\(r\\) = radius of target spacecraft's circular orbit \\(\\mu\\) = standard gravitational parameter \\(n\\) = mean motion of the target spacecraft (1) $$ n = \\sqrt{\\frac{ {\\mu} }{r^3}} $$","title":"Variables"},{"location":"calc/#clohesy-whiltshire-equation","text":"\\[ \\ddot x - 2n\\dot y - 3n^2x = a_{x} \\] \\[ \\ddot y + 2n\\dot x = a_{y} \\] \\[ \\ddot z + n^2 z = a_{z} \\] \\[ Thrust F_{x} = m_{Satellite}/ a_{x} \\] \\[ Thrust_{y} = F_{y}/m_{Satellite} \\] \\[ Thrust_{x} = F_{z}/m_{Satellite} \\] The Clohessy Whiltshire update is rewritten in matrix format as: \\(\\left[\\begin{array}{cc} \\dot x \\\\ \\dot y \\\\ \\dot z \\\\ \\dot v_{x} \\\\ \\dot v_{y} \\\\ \\dot v_{z} \\end{array}\\right] =\\) \\(\\left[\\begin{array}{cc} 0 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 3n^2 & 0 & 0 & 2n & 0 & 0 \\\\ 0 & -2n & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -n^2 & 0 \\end{array}\\right] *\\) \\(\\left[\\begin{array}{cc} x \\\\ y \\\\ z \\\\ v_{x} \\\\ v_{y} \\\\ v_{z} \\end{array}\\right] +\\) \\(\\left[\\begin{array}{cc} 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{array}\\right] *\\) \\(\\left[\\begin{array}{cc} F_{x} \\\\ F_{y} \\\\ F_{z} \\end{array}\\right]\\) This is mapped out in the Relative Trajectory function: def reltrajectorygenerate(self,U,x): accel = self.controller() return [U[3], U[4], U[5], 3*(self.n**2)*U[0]+2*self.n*U[4] + accel[0], -2*self.n*U[3] + accel[1], -(self.n**2)*U[2] + accel[2]]","title":"Clohesy Whiltshire Equation"},{"location":"home/","text":"Introduction This repository provides a satellite rendezvous simulation following the Clohessy Whiltshire Equations (CWH). Getting Started Installations Astropy pip install astropy NumPy pip3 install numpy SciPy pip3 install scipy Matplotlib pip3 install matplotlib Basic Mechanics \\(U_{target}\\) = state of target satellite relative to Earth \\(U_{chaser}\\) = state of chaser satellite relative to Earth The CWH equations describe the relative motion of a chaser spacecraft in circular/elliptical orbit around a target spacecraft in circular orbit. To update the state of the chaser at any time point, and obtain results as Earth frame instead of relative frame, requires the vector addition as shown $$ U_{chaser}(t) = U_{target}(t) + U_{chaser}^{update}(t) $$ INSERT diagram The update \\(U_{chaser}^{update}(t)\\) is obtained by solving the following equations using scipy's odeint solver $$ \\dot U = AU + BF $$ Matrix \\(A\\) contains the dynamics given by CWH. Matrix \\(B\\) maps the forces in the correct locations. More details can be found in the mechanics section. Usage System Parameters Most of the defined variables do not need to be changed for Earth-centric cubesat simulations. The following are variables that will differ from mission to mission: rad_tar = 6378.1+1020 # radius of target from earth center (km) mass = 1.33 # Chaser satellite mass (kg) meshsize = 1000 # Granularity of time step meshsize = 1000 # Granularity of time step periods = 1 initialstate = np.array([x, y, z, Vx, Vy, Vz]) # Initial state of chaser at the start of simulation thrustforce = np.array([Fx, Fy, Fz]) # Chaser thrust force Example Case A satellite (chaser) initiated an orbital transfer to approach the target satellite orbit. The simulation shows if it can maintain within a stable orbit, governed by the CWH equation. if __name__ == '__main__': # Take input as result from multi_sat.py, the last entries of X_NMT # X_NMT_last = [X_NMT[0,-1],X_NMT[1,-1],X_NMT[2,-1],X_NMT[3,-1],X_NMT[4,-1],X_NMT[5,-1]] X_NMT_last = np.array([-1000.1369261894047, -1484.113395146748, 0.0, -0.7620922284079551, 2.054281246393022, 0.0]) sim = CWHmotion() sim.initialstate = X_NMT_last rel_x,rel_y,rel_z, angles, chaser_x, chaser_y, chaser_z, coord = sim.main() https://en.wikipedia.org/wiki/Clohessy%E2%80%93Wiltshire_equations","title":"Home"},{"location":"home/#introduction","text":"This repository provides a satellite rendezvous simulation following the Clohessy Whiltshire Equations (CWH).","title":"Introduction"},{"location":"home/#getting-started","text":"","title":"Getting Started"},{"location":"home/#installations","text":"Astropy pip install astropy NumPy pip3 install numpy SciPy pip3 install scipy Matplotlib pip3 install matplotlib","title":"Installations"},{"location":"home/#basic-mechanics","text":"\\(U_{target}\\) = state of target satellite relative to Earth \\(U_{chaser}\\) = state of chaser satellite relative to Earth The CWH equations describe the relative motion of a chaser spacecraft in circular/elliptical orbit around a target spacecraft in circular orbit. To update the state of the chaser at any time point, and obtain results as Earth frame instead of relative frame, requires the vector addition as shown $$ U_{chaser}(t) = U_{target}(t) + U_{chaser}^{update}(t) $$ INSERT diagram The update \\(U_{chaser}^{update}(t)\\) is obtained by solving the following equations using scipy's odeint solver $$ \\dot U = AU + BF $$ Matrix \\(A\\) contains the dynamics given by CWH. Matrix \\(B\\) maps the forces in the correct locations. More details can be found in the mechanics section.","title":"Basic Mechanics"},{"location":"home/#usage","text":"","title":"Usage"},{"location":"home/#system-parameters","text":"Most of the defined variables do not need to be changed for Earth-centric cubesat simulations. The following are variables that will differ from mission to mission: rad_tar = 6378.1+1020 # radius of target from earth center (km) mass = 1.33 # Chaser satellite mass (kg) meshsize = 1000 # Granularity of time step meshsize = 1000 # Granularity of time step periods = 1 initialstate = np.array([x, y, z, Vx, Vy, Vz]) # Initial state of chaser at the start of simulation thrustforce = np.array([Fx, Fy, Fz]) # Chaser thrust force","title":"System Parameters"},{"location":"home/#example-case","text":"A satellite (chaser) initiated an orbital transfer to approach the target satellite orbit. The simulation shows if it can maintain within a stable orbit, governed by the CWH equation. if __name__ == '__main__': # Take input as result from multi_sat.py, the last entries of X_NMT # X_NMT_last = [X_NMT[0,-1],X_NMT[1,-1],X_NMT[2,-1],X_NMT[3,-1],X_NMT[4,-1],X_NMT[5,-1]] X_NMT_last = np.array([-1000.1369261894047, -1484.113395146748, 0.0, -0.7620922284079551, 2.054281246393022, 0.0]) sim = CWHmotion() sim.initialstate = X_NMT_last rel_x,rel_y,rel_z, angles, chaser_x, chaser_y, chaser_z, coord = sim.main() https://en.wikipedia.org/wiki/Clohessy%E2%80%93Wiltshire_equations","title":"Example Case"}]}